// PKGPATH: gno.land/r/aib/main
package main

import (
	"encoding/base64"
	"encoding/hex"
	"time"

	tmtesting "gno.land/p/aib/ibc/lightclient/tendermint/testing"
	"gno.land/p/aib/ibc/types"
	"gno.land/p/aib/ics23"
	"gno.land/r/aib/ibc/apps/vaas/consumer"
	"gno.land/r/aib/ibc/core"
)

// OnRecvPacket: success â€” receive a VSC packet from the provider and verify
// the validator set is updated.
func main() {
	var (
		chainID       = "chain-id-2"
		trustedHeight = types.NewHeight(2, 2)
		clientState   = tmtesting.NewClientState(chainID, trustedHeight)
		// NOTE this apphash was provided by the gen-proof command below.
		apphash, _     = hex.DecodeString("87c645b2174373448359ec6f3e229dcde8c822810be084d4817daf3f293d45eb")
		trustedValset  = tmtesting.GenValset()
		consensusState = tmtesting.GenConsensusState(time.Now(), apphash, trustedValset.Hash())
		counterpartyID = "07-tendermint-42"
	)
	clientID := core.CreateClient(cross, clientState, consensusState)
	core.RegisterCounterparty(cross, clientID, [][]byte{[]byte("iavlStoreKey"), []byte("prefix2")}, counterpartyID)

	// Construct the VSC packet payload in the provider's JSON format:
	//   {"validator_updates":[{"pub_key":{"ed25519":"<base64>"},"power":"<int64>"},...], "valset_update_id":"<uint64>"}
	payloadValue, _ := base64.StdEncoding.DecodeString("eyJ2YWxpZGF0b3JfdXBkYXRlcyI6W3sicHViX2tleSI6eyJlZDI1NTE5IjoiYVBGY0dPaTFQMm15clF0ZkV6NmJKaWtCRTNXb1cyVkh1ek1Famp4MmpLUT0ifSwicG93ZXIiOiIxMDAifSx7InB1Yl9rZXkiOnsiZWQyNTUxOSI6ImJQRmNHT2kxUDJteXJRdGZFejZiSmprQkUzV29XMlZIdXpNRWpqeDJqS1E9In0sInBvd2VyIjoiNTAifV0sInZhbHNldF91cGRhdGVfaWQiOiIxIn0=")
	println("Payload JSON:", string(payloadValue))

	// Generate the proof of existence of the packet commitment for the counterparty chain.
	specs := ics23.IavlSpec()
	// NOTE code generated by:
	// go run -C ./cmd/gen-proof . 'prefix2' '07-tendermint-42' 'packet' '{"sequence":1,"source_client":"07-tendermint-42","destination_client":"07-tendermint-1","timeout_timestamp":1234571490,"payloads":[{"source_port":"vaas/provider","destination_port":"vaas/consumer","encoding":"application/json","value":"eyJ2YWxpZGF0b3JfdXBkYXRlcyI6W3sicHViX2tleSI6eyJlZDI1NTE5IjoiYVBGY0dPaTFQMm15clF0ZkV6NmJKaWtCRTNXb1cyVkh1ek1Famp4MmpLUT0ifSwicG93ZXIiOiIxMDAifSx7InB1Yl9rZXkiOnsiZWQyNTUxOSI6ImJQRmNHT2kxUDJteXJRdGZFejZiSmprQkUzV29XMlZIdXpNRWpqeDJqS1E9In0sInBvd2VyIjoiNTAifV0sInZhbHNldF91cGRhdGVfaWQiOiIxIn0=","version":"1"}]}'
	proof := []ics23.CommitmentProof{

		// iavl proof
		ics23.CommitmentProof_Exist{
			Exist: &ics23.ExistenceProof{
				Key:   []byte("\x70\x72\x65\x66\x69\x78\x32\x30\x37\x2d\x74\x65\x6e\x64\x65\x72\x6d\x69\x6e\x74\x2d\x34\x32\x01\x00\x00\x00\x00\x00\x00\x00\x01"),
				Value: []byte("\x2e\x68\x87\xac\xb0\x8c\x7e\x10\xf3\xc8\x41\xff\x82\x7e\x1f\xd0\xb5\xa1\x4c\xae\x61\x6e\x69\x02\x7c\x46\xec\x99\x31\x1d\x66\xc6"),
				Leaf: &ics23.LeafOp{
					Hash:         specs.LeafSpec.Hash,
					PrehashKey:   specs.LeafSpec.PrehashKey,
					PrehashValue: specs.LeafSpec.PrehashValue,
					Length:       specs.LeafSpec.Length,
					Prefix:       []byte("\x00\x02\x02"),
				},
				Path: []*ics23.InnerOp{
					{
						Hash:   specs.InnerSpec.Hash,
						Prefix: []byte("\x02\x04\x02\x20\x35\xf8\xea\x80\x53\x90\xe0\x84\x85\x4f\x39\x9b\x42\xcc\xde\xae\xa3\x3a\x1d\xed\xc1\x15\x63\x8a\xc4\x8d\x06\x00\x63\x7d\xba\x1f\x20"),
						Suffix: []byte(""),
					},
					{
						Hash:   specs.InnerSpec.Hash,
						Prefix: []byte("\x04\x08\x02\x20"),
						Suffix: []byte("\x20\x79\x8e\x2c\xaa\x96\xfd\xfb\xa3\x76\xdd\xeb\x47\x99\x99\x54\xd2\xf4\x7e\x65\x16\x22\x64\xb0\x53\x6a\xb5\xdf\xf7\xfc\x0a\x2e\x07"),
					},
					{
						Hash:   specs.InnerSpec.Hash,
						Prefix: []byte("\x06\x0c\x02\x20\x9a\xf3\x7d\xd5\x95\xa0\x19\x08\x03\xb5\xe0\x5a\xae\xf4\x2a\xe3\xfa\xd4\x99\xe4\xfb\xe3\x7f\x7c\xd3\x1c\xad\xff\x22\xa9\xee\x74\x20"),
						Suffix: []byte(""),
					},
				},
			},
		},

		// rootmulti proof
		ics23.CommitmentProof_Exist{
			Exist: &ics23.ExistenceProof{
				Key:   []byte("\x69\x61\x76\x6c\x53\x74\x6f\x72\x65\x4b\x65\x79"),
				Value: []byte("\x96\x00\x74\x6d\x6d\x49\x2b\x83\x82\xe1\xda\x51\x7f\x7f\x05\xdd\xb2\xdf\xfa\x01\x77\x92\x1b\x50\x46\xd1\x48\x34\xa1\x53\x50\x6c"),
				Leaf: &ics23.LeafOp{
					Hash:         specs.LeafSpec.Hash,
					PrehashKey:   specs.LeafSpec.PrehashKey,
					PrehashValue: specs.LeafSpec.PrehashValue,
					Length:       specs.LeafSpec.Length,
					Prefix:       []byte("\x00"),
				},
				Path: []*ics23.InnerOp{},
			},
		},
	}

	recvPacket := types.MsgRecvPacket{
		Packet: types.Packet{
			Sequence:          1,
			SourceClient:      counterpartyID,
			DestinationClient: clientID,
			TimeoutTimestamp:  uint64(time.Now().Add(time.Hour).Unix()),
			Payloads: []types.Payload{{
				SourcePort:      consumer.ProviderPortID,
				DestinationPort: consumer.PortID,
				Encoding:        consumer.EncodingJSON,
				Value:           payloadValue,
				Version:         consumer.Version,
			}},
		},
		ProofCommitment: proof,
		ProofHeight:     trustedHeight,
	}

	println("\n--- Before RecvPacket ---")
	println("validator count:", consumer.GetCCValidatorCount())
	println("total voting power:", consumer.GetTotalVotingPower())

	res := core.RecvPacket(cross, recvPacket)
	println("\n--- After RecvPacket ---")
	println("result:", res)

	// Verify the validator set was updated
	println("validator count:", consumer.GetCCValidatorCount())
	println("total voting power:", consumer.GetTotalVotingPower())

	// Verify provider client was set
	providerClient, ok := consumer.GetProviderClientID()
	println("provider client set:", ok)
	println("provider client:", providerClient)

	// Verify last valset update ID
	println("last valset update id:", consumer.GetLastValsetUpdateID())

	// Verify highest valset update ID (for out-of-order packet tracking)
	println("highest valset update id:", consumer.GetHighestValsetUpdateID())

	// Verify individual validators
	vals := consumer.GetAllCCValidators()
	for _, v := range vals {
		println("validator:", v.PubKey, "power:", v.Power)
	}

	// Verify render output
	println("\n--- Render ---")
	println(consumer.Render(""))
}

// NOTE: If the packet format changes, regenerate the merkle proof:
//   go run -C ./cmd/gen-proof . 'prefix2' '07-tendermint-42' 'packet' '<packet_json>'

// Output:
// Payload JSON: {"validator_updates":[{"pub_key":{"ed25519":"aPFcGOi1P2myrQtfEz6bJikBE3WoW2VHuzMEjjx2jKQ="},"power":"100"},{"pub_key":{"ed25519":"bPFcGOi1P2myrQtfEz6bJjkBE3WoW2VHuzMEjjx2jKQ="},"power":"50"}],"valset_update_id":"1"}
//
// --- Before RecvPacket ---
// validator count: 0
// total voting power: 0
//
// --- After RecvPacket ---
// result: (2 gno.land/p/aib/ibc/types.ResponseResultType)
// validator count: 2
// total voting power: 150
// provider client set: true
// provider client: 07-tendermint-42
// last valset update id: 1
// highest valset update id: 1
// validator: ed25519:aPFcGOi1P2myrQtfEz6bJikBE3WoW2VHuzMEjjx2jKQ= power: 100
// validator: ed25519:bPFcGOi1P2myrQtfEz6bJjkBE3WoW2VHuzMEjjx2jKQ= power: 50
//
// --- Render ---
// # VAAS Consumer
//
// **Provider Client:** `07-tendermint-42`
//
// **Last Valset Update ID:** 1
//
// **Highest Valset Update ID:** 1
//
// ## Validator Set (2 validators)
//
// **Total Voting Power:** 150
//
// | PubKey | Power |
// | --- | --- |
// | `ed25519:aPFcGO...x2jKQ=` | 100 |
// | `ed25519:bPFcGO...x2jKQ=` | 50 |
//
// ---
//
// ## IBC App Info
//
// - **Port ID:** `vaas/consumer`
// - **Provider Port ID:** `vaas/provider`
// - **Version:** `1`
// - **Encoding:** `application/json`
